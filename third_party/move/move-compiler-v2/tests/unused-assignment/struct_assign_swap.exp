============ initial bytecode ================

[variant baseline]
fun m::swap1($t0: u32, $t1: u32): (u32, u32) {
     var $t2: u32
     var $t3: u32
     var $t4: u32
     var $t5: u32
     var $t6: m::S
  0: $t6 := pack m::S($t1, $t0)
  1: ($t4, $t5) := unpack m::S($t6)
  2: $t2 := infer($t4)
  3: $t3 := infer($t5)
  4: return ($t2, $t3)
}


[variant baseline]
fun m::swap2(): (u32, u32) {
     var $t0: u32
     var $t1: u32
     var $t2: u32
     var $t3: u32
     var $t4: m::S
     var $t5: u32
     var $t6: u32
  0: $t5 := 55
  1: $t6 := 44
  2: $t4 := pack m::S($t5, $t6)
  3: ($t2, $t3) := unpack m::S($t4)
  4: $t0 := 55
  5: $t1 := 44
  6: return ($t0, $t1)
}


[variant baseline]
fun m::test1(): (u32, u32) {
     var $t0: u32
     var $t1: u32
     var $t2: u32
     var $t3: u32
  0: $t2 := 1
  1: $t3 := 2
  2: ($t0, $t1) := m::swap1($t2, $t3)
  3: return ($t0, $t1)
}

============ after uninitialized_use_checker: ================

[variant baseline]
fun m::swap1($t0: u32, $t1: u32): (u32, u32) {
     var $t2: u32
     var $t3: u32
     var $t4: u32
     var $t5: u32
     var $t6: m::S
  0: $t6 := pack m::S($t1, $t0)
  1: ($t4, $t5) := unpack m::S($t6)
  2: $t2 := infer($t4)
  3: $t3 := infer($t5)
  4: return ($t2, $t3)
}


[variant baseline]
fun m::swap2(): (u32, u32) {
     var $t0: u32
     var $t1: u32
     var $t2: u32
     var $t3: u32
     var $t4: m::S
     var $t5: u32
     var $t6: u32
  0: $t5 := 55
  1: $t6 := 44
  2: $t4 := pack m::S($t5, $t6)
  3: ($t2, $t3) := unpack m::S($t4)
  4: $t0 := 55
  5: $t1 := 44
  6: return ($t0, $t1)
}


[variant baseline]
fun m::test1(): (u32, u32) {
     var $t0: u32
     var $t1: u32
     var $t2: u32
     var $t3: u32
  0: $t2 := 1
  1: $t3 := 2
  2: ($t0, $t1) := m::swap1($t2, $t3)
  3: return ($t0, $t1)
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun m::swap1($t0: u32, $t1: u32): (u32, u32) {
     var $t2: u32
     var $t3: u32
     var $t4: u32
     var $t5: u32
     var $t6: m::S
     # live vars: $t0, $t1
  0: $t6 := pack m::S($t1, $t0)
     # live vars: $t6
  1: ($t4, $t5) := unpack m::S($t6)
     # live vars: $t4, $t5
  2: $t2 := infer($t4)
     # live vars: $t2, $t5
  3: $t3 := infer($t5)
     # live vars: $t2, $t3
  4: return ($t2, $t3)
}


[variant baseline]
fun m::swap2(): (u32, u32) {
     var $t0: u32
     var $t1: u32
     var $t2: u32
     var $t3: u32
     var $t4: m::S
     var $t5: u32
     var $t6: u32
     # live vars:
  0: $t5 := 55
     # live vars: $t5
  1: $t6 := 44
     # live vars: $t5, $t6
  2: $t4 := pack m::S($t5, $t6)
     # live vars: $t4
  3: ($t2, $t3) := unpack m::S($t4)
     # live vars:
  4: $t0 := 55
     # live vars: $t0
  5: $t1 := 44
     # live vars: $t0, $t1
  6: return ($t0, $t1)
}


[variant baseline]
fun m::test1(): (u32, u32) {
     var $t0: u32
     var $t1: u32
     var $t2: u32
     var $t3: u32
     # live vars:
  0: $t2 := 1
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: ($t0, $t1) := m::swap1($t2, $t3)
     # live vars: $t0, $t1
  3: return ($t0, $t1)
}


Diagnostics:
warning: Unused assignment to `x`. Consider removing or prefixing with an underscore: `_x`
   ┌─ tests/unused-assignment/struct_assign_swap.move:16:13
   │
16 │         let S { f: x, g: y } = S { f: y, g: x };
   │             ^^^^^^^^^^^^^^^^

warning: Unused assignment to `y`. Consider removing or prefixing with an underscore: `_y`
   ┌─ tests/unused-assignment/struct_assign_swap.move:16:13
   │
16 │         let S { f: x, g: y } = S { f: y, g: x };
   │             ^^^^^^^^^^^^^^^^

============ after UnusedAssignmentChecker: ================

[variant baseline]
fun m::swap1($t0: u32, $t1: u32): (u32, u32) {
     var $t2: u32
     var $t3: u32
     var $t4: u32
     var $t5: u32
     var $t6: m::S
     # live vars: $t0, $t1
  0: $t6 := pack m::S($t1, $t0)
     # live vars: $t6
  1: ($t4, $t5) := unpack m::S($t6)
     # live vars: $t4, $t5
  2: $t2 := infer($t4)
     # live vars: $t2, $t5
  3: $t3 := infer($t5)
     # live vars: $t2, $t3
  4: return ($t2, $t3)
}


[variant baseline]
fun m::swap2(): (u32, u32) {
     var $t0: u32
     var $t1: u32
     var $t2: u32
     var $t3: u32
     var $t4: m::S
     var $t5: u32
     var $t6: u32
     # live vars:
  0: $t5 := 55
     # live vars: $t5
  1: $t6 := 44
     # live vars: $t5, $t6
  2: $t4 := pack m::S($t5, $t6)
     # live vars: $t4
  3: ($t2, $t3) := unpack m::S($t4)
     # live vars:
  4: $t0 := 55
     # live vars: $t0
  5: $t1 := 44
     # live vars: $t0, $t1
  6: return ($t0, $t1)
}


[variant baseline]
fun m::test1(): (u32, u32) {
     var $t0: u32
     var $t1: u32
     var $t2: u32
     var $t3: u32
     # live vars:
  0: $t2 := 1
     # live vars: $t2
  1: $t3 := 2
     # live vars: $t2, $t3
  2: ($t0, $t1) := m::swap1($t2, $t3)
     # live vars: $t0, $t1
  3: return ($t0, $t1)
}
