
Diagnostics:
warning: Unused local variable `y`. Consider removing or prefixing with an underscore: `_y`
  ┌─ tests/ability-checker/release.move:6:7
  │
6 │         let y = &x;
  │             ^

============ initial bytecode ================

[variant baseline]
fun test::test() {
     var $t0: test::Impotent
     var $t1: test::Impotent
     var $t2: bool
     var $t3: &test::Impotent
     var $t4: &test::Impotent
  0: $t2 := false
  1: $t1 := pack test::Impotent($t2)
  2: $t0 := infer($t1)
  3: $t4 := borrow_local($t0)
  4: $t3 := infer($t4)
  5: return ()
}

============ after LiveVarAnalysisProcessor: ================

[variant baseline]
fun test::test() {
     var $t0: test::Impotent
     var $t1: test::Impotent
     var $t2: bool
     var $t3: &test::Impotent
     var $t4: &test::Impotent
     # live vars:
  0: $t2 := false
     # live vars: $t2
  1: $t1 := pack test::Impotent($t2)
     # live vars: $t1
  2: $t0 := move($t1)
     # live vars: $t0
  3: $t4 := borrow_local($t0)
     # live vars: $t4
  4: $t3 := move($t4)
     # live vars:
  5: return ()
}

============ after MemorySafetyProcessor: ================

[variant baseline]
fun test::test() {
     var $t0: test::Impotent
     var $t1: test::Impotent
     var $t2: bool
     var $t3: &test::Impotent
     var $t4: &test::Impotent
     # live vars:
     # graph: {}
     # local_to_label: {}
     # global_to_label: {}
     # moved: {}
     #
  0: $t2 := false
     # live vars: $t2
     # graph: {}
     # local_to_label: {}
     # global_to_label: {}
     # moved: {}
     #
  1: $t1 := pack test::Impotent($t2)
     # live vars: $t1
     # graph: {}
     # local_to_label: {}
     # global_to_label: {}
     # moved: {$t2}
     #
  2: $t0 := move($t1)
     # live vars: $t0
     # graph: {}
     # local_to_label: {}
     # global_to_label: {}
     # moved: {$t1,$t2}
     #
  3: $t4 := borrow_local($t0)
     # live vars: $t4
     # graph: {L768=local($t0)[borrow(false) -> L769],L769=local($t4)[]}
     # local_to_label: {$t0=L768,$t4=L769}
     # global_to_label: {}
     # moved: {$t1,$t2}
     #
  4: $t3 := move($t4)
     # live vars:
     # graph: {}
     # local_to_label: {}
     # global_to_label: {}
     # moved: {$t1,$t2,$t4}
     #
  5: return ()
}

============ after ExplicitDrop: ================

[variant baseline]
fun test::test() {
     var $t0: test::Impotent
     var $t1: test::Impotent
     var $t2: bool
     var $t3: &test::Impotent
     var $t4: &test::Impotent
  0: $t2 := false
  1: $t1 := pack test::Impotent($t2)
  2: $t0 := move($t1)
  3: $t4 := borrow_local($t0)
  4: $t3 := move($t4)
  5: release($t0)
  6: drop($t3)
  7: return ()
}

============ after AbortAnalysisProcessor: ================

[variant baseline]
fun test::test() {
     var $t0: test::Impotent
     var $t1: test::Impotent
     var $t2: bool
     var $t3: &test::Impotent
     var $t4: &test::Impotent
     # abort state before: {returns}
     # abort state after : {returns}
  0: $t2 := false
     # abort state before: {returns}
     # abort state after : {returns}
  1: $t1 := pack test::Impotent($t2)
     # abort state before: {returns}
     # abort state after : {returns}
  2: $t0 := move($t1)
     # abort state before: {returns}
     # abort state after : {returns}
  3: $t4 := borrow_local($t0)
     # abort state before: {returns}
     # abort state after : {returns}
  4: $t3 := move($t4)
     # abort state before: {returns}
     # abort state after : {returns}
  5: release($t0)
     # abort state before: {returns}
     # abort state after : {returns}
  6: drop($t3)
     # abort state before: {returns}
     # abort state after : {}
  7: return ()
}


Diagnostics:
error: cannot drop
  ┌─ tests/ability-checker/release.move:6:7
  │
6 │         let y = &x;
  │             ^

============ after AbilityChecker: ================

[variant baseline]
fun test::test() {
     var $t0: test::Impotent
     var $t1: test::Impotent
     var $t2: bool
     var $t3: &test::Impotent
     var $t4: &test::Impotent
     # abort state before: {returns}
     # abort state after : {returns}
  0: $t2 := false
     # abort state before: {returns}
     # abort state after : {returns}
  1: $t1 := pack test::Impotent($t2)
     # abort state before: {returns}
     # abort state after : {returns}
  2: $t0 := move($t1)
     # abort state before: {returns}
     # abort state after : {returns}
  3: $t4 := borrow_local($t0)
     # abort state before: {returns}
     # abort state after : {returns}
  4: $t3 := move($t4)
     # abort state before: {returns}
     # abort state after : {returns}
  5: release($t0)
     # abort state before: {returns}
     # abort state after : {returns}
  6: drop($t3)
     # abort state before: {returns}
     # abort state after : {}
  7: return ()
}
