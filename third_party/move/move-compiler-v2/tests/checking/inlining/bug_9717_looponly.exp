// ---- Model Dump
module 0xcafe::vectors {
    use std::vector;
    public entry fun entry_test_guess_flips_abort() {
        {
          let flips: vector<u8> = Vector<u8>(0, 0, 0, 0);
          vectors::guess_flips_abort(flips);
          Tuple()
        }
    }
    public entry fun entry_test_guess_flips_break() {
        {
          let flips: vector<u8> = Vector<u8>(0, 0, 0, 0);
          vectors::guess_flips_break(flips);
          Tuple()
        }
    }
    public entry fun entry_test_guess_flips_break2() {
        {
          let flips: vector<u8> = Vector<u8>(0, 0, 0, 0);
          vectors::guess_flips_break2(flips);
          Tuple()
        }
    }
    public entry fun entry_test_guess_flips_continue() {
        {
          let flips: vector<u8> = Vector<u8>(0, 0, 0, 0);
          vectors::guess_flips_continue(flips);
          Tuple()
        }
    }
    public entry fun entry_test_guess_flips_nocheck() {
        {
          let flips: vector<u8> = Vector<u8>(0, 0, 0, 0);
          vectors::guess_flips_nocheck(flips);
          Tuple()
        }
    }
    public entry fun guess_flips_abort(flips: vector<u8>) {
        {
          let i: u64 = 0;
          {
            let flipsref2: &vector<u8> = Borrow(Immutable)(flips);
            loop {
              if Lt<u64>(i, vector::length<u8>(flipsref2)) {
                if Eq<u8>(Deref(vector::borrow<u8>(flipsref2, i)), 0) {
                  Tuple()
                } else {
                  Abort(3)
                };
                i: u64 = Add<u64>(i, 1);
                Tuple()
              } else {
                break
              }
            };
            {
              let _v: vector<u8> = Copy(flips);
              {
                let _v2: vector<u8> = flips;
                Tuple()
              }
            }
          }
        }
    }
    public entry fun guess_flips_break(flips: vector<u8>) {
        {
          let i: u64 = 0;
          {
            let flipsref1: &vector<u8> = Borrow(Immutable)(flips);
            loop {
              if Lt<u64>(i, vector::length<u8>(flipsref1)) {
                if Neq<u8>(Deref(vector::borrow<u8>(flipsref1, i)), 0) {
                  break
                } else {
                  Tuple()
                };
                i: u64 = Add<u64>(i, 1);
                Tuple()
              } else {
                break
              }
            };
            {
              let _v: vector<u8> = Copy(flips);
              {
                let _v2: vector<u8> = flips;
                Tuple()
              }
            }
          }
        }
    }
    public entry fun guess_flips_break2(flips: vector<u8>): u64 {
        {
          let i: u64 = 0;
          {
            let flipsref5: &vector<u8> = Borrow(Immutable)(flips);
            loop {
              if Lt<u64>(i, vector::length<u8>(flipsref5)) {
                if Neq<u8>(Deref(vector::borrow<u8>(flipsref5, i)), 0) {
                  break
                } else {
                  Tuple()
                };
                i: u64 = Add<u64>(i, 1);
                if Eq<u8>(Deref(vector::borrow<u8>(flipsref5, i)), 5) {
                  break
                } else {
                  Tuple()
                };
                Tuple()
              } else {
                break
              }
            };
            {
              let _v: vector<u8> = Copy(flips);
              {
                let _v2: vector<u8> = flips;
                {
                  let x: &vector<u8> = flipsref5;
                  vector::length<u8>(x)
                }
              }
            }
          }
        }
    }
    public entry fun guess_flips_continue(flips: vector<u8>) {
        {
          let i: u64 = 0;
          {
            let flipsref4: &vector<u8> = Borrow(Immutable)(flips);
            loop {
              if Lt<u64>(i, vector::length<u8>(flipsref4)) {
                if Neq<u8>(Deref(vector::borrow<u8>(flipsref4, i)), 0) {
                  continue
                } else {
                  Tuple()
                };
                i: u64 = Add<u64>(i, 1);
                Tuple()
              } else {
                break
              }
            };
            {
              let _v: vector<u8> = Copy(flips);
              {
                let _v2: vector<u8> = flips;
                Tuple()
              }
            }
          }
        }
    }
    public entry fun guess_flips_nocheck(flips: vector<u8>) {
        {
          let i: u64 = 0;
          {
            let flipsref3: &vector<u8> = Borrow(Immutable)(flips);
            loop {
              if Lt<u64>(i, vector::length<u8>(flipsref3)) {
                i: u64 = Add<u64>(i, 1);
                Tuple()
              } else {
                break
              }
            };
            {
              let _v: vector<u8> = Copy(flips);
              {
                let _v2: vector<u8> = flips;
                Tuple()
              }
            }
          }
        }
    }
    private fun test_guess_flips_abort() {
        {
          let flips: vector<u8> = Vector<u8>(0, 0, 0, 0);
          vectors::guess_flips_abort(flips);
          Tuple()
        }
    }
    private fun test_guess_flips_break() {
        {
          let flips: vector<u8> = Vector<u8>(0, 0, 0, 0);
          vectors::guess_flips_break(flips);
          Tuple()
        }
    }
    private fun test_guess_flips_break2() {
        {
          let flips: vector<u8> = Vector<u8>(0, 0, 0, 0);
          vectors::guess_flips_break2(flips);
          Tuple()
        }
    }
    private fun test_guess_flips_continue() {
        {
          let flips: vector<u8> = Vector<u8>(0, 0, 0, 0);
          vectors::guess_flips_continue(flips);
          Tuple()
        }
    }
    private fun test_guess_flips_nocheck() {
        {
          let flips: vector<u8> = Vector<u8>(0, 0, 0, 0);
          vectors::guess_flips_nocheck(flips);
          Tuple()
        }
    }
    spec fun $entry_test_guess_flips_abort();
    spec fun $entry_test_guess_flips_break();
    spec fun $entry_test_guess_flips_break2();
    spec fun $entry_test_guess_flips_continue();
    spec fun $entry_test_guess_flips_nocheck();
    spec fun $guess_flips_abort(flips: vector<u8>);
    spec fun $guess_flips_break(flips: vector<u8>);
    spec fun $guess_flips_break2(flips: vector<u8>): u64;
    spec fun $guess_flips_continue(flips: vector<u8>);
    spec fun $guess_flips_nocheck(flips: vector<u8>);
    spec fun $test_guess_flips_abort();
    spec fun $test_guess_flips_break();
    spec fun $test_guess_flips_break2();
    spec fun $test_guess_flips_continue();
    spec fun $test_guess_flips_nocheck();
} // end 0xcafe::vectors
