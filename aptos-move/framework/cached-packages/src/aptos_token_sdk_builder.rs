// Copyright (c) Aptos
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

// Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
// standard BCS-compatible representation used in Aptos transactions (`Script`).
//
// This code was generated by compiling known Script interfaces ("ABIs") with the tool `transaction-builder-generator`.

use aptos_types::{
    account_address::AccountAddress,
    transaction::{Script, ScriptFunction, TransactionArgument, TransactionPayload, VecBytes},
};
use move_deps::move_core_types::{ident_str, language_storage::ModuleId};

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move script function.
/// ```ignore
/// impl ScriptFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<ScriptFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
#[allow(non_camel_case_types)]
pub enum ScriptFunctionCall {
    /// create a empty token collection with parameters
    tokenCreateCollectionScript {
        name: Bytes,
        description: Bytes,
        uri: Bytes,
        maximum: u64,
        mutate_setting: Vec<bool>,
    },

    /// create token with raw inputs
    tokenCreateTokenScript {
        collection: Bytes,
        name: Bytes,
        description: Bytes,
        balance: u64,
        maximum: u64,
        uri: Bytes,
        royalty_payee_address: AccountAddress,
        royalty_points_denominator: u64,
        royalty_points_nominator: u64,
        token_mutate_setting: Vec<bool>,
        property_keys: VecBytes,
        property_values: VecBytes,
        property_types: VecBytes,
    },

    tokenDirectTransferScript {
        creators_address: AccountAddress,
        collection: Bytes,
        name: Bytes,
        amount: u64,
        serial_number: u64,
    },

    tokenInitializeTokenScript {},

    /// Mint more token from an existing token_data. Mint only adds more token to serial_number 0
    tokenMint {
        token_data_address: AccountAddress,
        collection: Bytes,
        name: Bytes,
        amount: u64,
    },

    token_transfersCancelOfferScript {
        receiver: AccountAddress,
        creator: AccountAddress,
        collection: Bytes,
        name: Bytes,
        serial_number: u64,
    },

    token_transfersClaimScript {
        sender: AccountAddress,
        creator: AccountAddress,
        collection: Bytes,
        name: Bytes,
        serial_number: u64,
    },

    token_transfersOfferScript {
        receiver: AccountAddress,
        creator: AccountAddress,
        collection: Bytes,
        name: Bytes,
        amount: u64,
        serial_number: u64,
    },
}

impl ScriptFunctionCall {
    /// Build an Aptos `TransactionPayload` from a structured object `ScriptFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use ScriptFunctionCall::*;
        match self {
            tokenCreateCollectionScript {
                name,
                description,
                uri,
                maximum,
                mutate_setting,
            } => encode_token_create_collection_script(
                name,
                description,
                uri,
                maximum,
                mutate_setting,
            ),
            tokenCreateTokenScript {
                collection,
                name,
                description,
                balance,
                maximum,
                uri,
                royalty_payee_address,
                royalty_points_denominator,
                royalty_points_nominator,
                token_mutate_setting,
                property_keys,
                property_values,
                property_types,
            } => encode_token_create_token_script(
                collection,
                name,
                description,
                balance,
                maximum,
                uri,
                royalty_payee_address,
                royalty_points_denominator,
                royalty_points_nominator,
                token_mutate_setting,
                property_keys,
                property_values,
                property_types,
            ),
            tokenDirectTransferScript {
                creators_address,
                collection,
                name,
                amount,
                serial_number,
            } => encode_token_direct_transfer_script(
                creators_address,
                collection,
                name,
                amount,
                serial_number,
            ),
            tokenInitializeTokenScript {} => encode_token_initialize_token_script(),
            tokenMint {
                token_data_address,
                collection,
                name,
                amount,
            } => encode_token_mint(token_data_address, collection, name, amount),
            token_transfersCancelOfferScript {
                receiver,
                creator,
                collection,
                name,
                serial_number,
            } => encode_token_transfers_cancel_offer_script(
                receiver,
                creator,
                collection,
                name,
                serial_number,
            ),
            token_transfersClaimScript {
                sender,
                creator,
                collection,
                name,
                serial_number,
            } => encode_token_transfers_claim_script(
                sender,
                creator,
                collection,
                name,
                serial_number,
            ),
            token_transfersOfferScript {
                receiver,
                creator,
                collection,
                name,
                amount,
                serial_number,
            } => encode_token_transfers_offer_script(
                receiver,
                creator,
                collection,
                name,
                amount,
                serial_number,
            ),
        }
    }

    /// Try to recognize an Aptos `TransactionPayload` and convert it into a structured object `ScriptFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
        if let TransactionPayload::ScriptFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!(
                "{}{}",
                script.module().name(),
                script.function()
            )) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }
}

/// create a empty token collection with parameters
pub fn encode_token_create_collection_script(
    name: Vec<u8>,
    description: Vec<u8>,
    uri: Vec<u8>,
    maximum: u64,
    mutate_setting: Vec<bool>,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("create_collection_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&maximum).unwrap(),
            bcs::to_bytes(&mutate_setting).unwrap(),
        ],
    ))
}

/// create token with raw inputs
pub fn encode_token_create_token_script(
    collection: Vec<u8>,
    name: Vec<u8>,
    description: Vec<u8>,
    balance: u64,
    maximum: u64,
    uri: Vec<u8>,
    royalty_payee_address: AccountAddress,
    royalty_points_denominator: u64,
    royalty_points_nominator: u64,
    token_mutate_setting: Vec<bool>,
    property_keys: VecBytes,
    property_values: VecBytes,
    property_types: VecBytes,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("create_token_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&balance).unwrap(),
            bcs::to_bytes(&maximum).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&royalty_payee_address).unwrap(),
            bcs::to_bytes(&royalty_points_denominator).unwrap(),
            bcs::to_bytes(&royalty_points_nominator).unwrap(),
            bcs::to_bytes(&token_mutate_setting).unwrap(),
            bcs::to_bytes(&property_keys).unwrap(),
            bcs::to_bytes(&property_values).unwrap(),
            bcs::to_bytes(&property_types).unwrap(),
        ],
    ))
}

pub fn encode_token_direct_transfer_script(
    creators_address: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
    amount: u64,
    serial_number: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("direct_transfer_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&creators_address).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
            bcs::to_bytes(&serial_number).unwrap(),
        ],
    ))
}

pub fn encode_token_initialize_token_script() -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("initialize_token_script").to_owned(),
        vec![],
        vec![],
    ))
}

/// Mint more token from an existing token_data. Mint only adds more token to serial_number 0
pub fn encode_token_mint(
    token_data_address: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
    amount: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&token_data_address).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

pub fn encode_token_transfers_cancel_offer_script(
    receiver: AccountAddress,
    creator: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
    serial_number: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token_transfers").to_owned(),
        ),
        ident_str!("cancel_offer_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&receiver).unwrap(),
            bcs::to_bytes(&creator).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&serial_number).unwrap(),
        ],
    ))
}

pub fn encode_token_transfers_claim_script(
    sender: AccountAddress,
    creator: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
    serial_number: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token_transfers").to_owned(),
        ),
        ident_str!("claim_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&sender).unwrap(),
            bcs::to_bytes(&creator).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&serial_number).unwrap(),
        ],
    ))
}

pub fn encode_token_transfers_offer_script(
    receiver: AccountAddress,
    creator: AccountAddress,
    collection: Vec<u8>,
    name: Vec<u8>,
    amount: u64,
    serial_number: u64,
) -> TransactionPayload {
    TransactionPayload::ScriptFunction(ScriptFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("token_transfers").to_owned(),
        ),
        ident_str!("offer_script").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&receiver).unwrap(),
            bcs::to_bytes(&creator).unwrap(),
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
            bcs::to_bytes(&serial_number).unwrap(),
        ],
    ))
}

fn decode_token_create_collection_script(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::tokenCreateCollectionScript {
            name: bcs::from_bytes(script.args().get(0)?).ok()?,
            description: bcs::from_bytes(script.args().get(1)?).ok()?,
            uri: bcs::from_bytes(script.args().get(2)?).ok()?,
            maximum: bcs::from_bytes(script.args().get(3)?).ok()?,
            mutate_setting: bcs::from_bytes(script.args().get(4)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_create_token_script(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::tokenCreateTokenScript {
            collection: bcs::from_bytes(script.args().get(0)?).ok()?,
            name: bcs::from_bytes(script.args().get(1)?).ok()?,
            description: bcs::from_bytes(script.args().get(2)?).ok()?,
            balance: bcs::from_bytes(script.args().get(3)?).ok()?,
            maximum: bcs::from_bytes(script.args().get(4)?).ok()?,
            uri: bcs::from_bytes(script.args().get(5)?).ok()?,
            royalty_payee_address: bcs::from_bytes(script.args().get(6)?).ok()?,
            royalty_points_denominator: bcs::from_bytes(script.args().get(7)?).ok()?,
            royalty_points_nominator: bcs::from_bytes(script.args().get(8)?).ok()?,
            token_mutate_setting: bcs::from_bytes(script.args().get(9)?).ok()?,
            property_keys: bcs::from_bytes(script.args().get(10)?).ok()?,
            property_values: bcs::from_bytes(script.args().get(11)?).ok()?,
            property_types: bcs::from_bytes(script.args().get(12)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_direct_transfer_script(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::tokenDirectTransferScript {
            creators_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            collection: bcs::from_bytes(script.args().get(1)?).ok()?,
            name: bcs::from_bytes(script.args().get(2)?).ok()?,
            amount: bcs::from_bytes(script.args().get(3)?).ok()?,
            serial_number: bcs::from_bytes(script.args().get(4)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_initialize_token_script(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(_script) = payload {
        Some(ScriptFunctionCall::tokenInitializeTokenScript {})
    } else {
        None
    }
}

fn decode_token_mint(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::tokenMint {
            token_data_address: bcs::from_bytes(script.args().get(0)?).ok()?,
            collection: bcs::from_bytes(script.args().get(1)?).ok()?,
            name: bcs::from_bytes(script.args().get(2)?).ok()?,
            amount: bcs::from_bytes(script.args().get(3)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_transfers_cancel_offer_script(
    payload: &TransactionPayload,
) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::token_transfersCancelOfferScript {
            receiver: bcs::from_bytes(script.args().get(0)?).ok()?,
            creator: bcs::from_bytes(script.args().get(1)?).ok()?,
            collection: bcs::from_bytes(script.args().get(2)?).ok()?,
            name: bcs::from_bytes(script.args().get(3)?).ok()?,
            serial_number: bcs::from_bytes(script.args().get(4)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_transfers_claim_script(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::token_transfersClaimScript {
            sender: bcs::from_bytes(script.args().get(0)?).ok()?,
            creator: bcs::from_bytes(script.args().get(1)?).ok()?,
            collection: bcs::from_bytes(script.args().get(2)?).ok()?,
            name: bcs::from_bytes(script.args().get(3)?).ok()?,
            serial_number: bcs::from_bytes(script.args().get(4)?).ok()?,
        })
    } else {
        None
    }
}

fn decode_token_transfers_offer_script(payload: &TransactionPayload) -> Option<ScriptFunctionCall> {
    if let TransactionPayload::ScriptFunction(script) = payload {
        Some(ScriptFunctionCall::token_transfersOfferScript {
            receiver: bcs::from_bytes(script.args().get(0)?).ok()?,
            creator: bcs::from_bytes(script.args().get(1)?).ok()?,
            collection: bcs::from_bytes(script.args().get(2)?).ok()?,
            name: bcs::from_bytes(script.args().get(3)?).ok()?,
            amount: bcs::from_bytes(script.args().get(4)?).ok()?,
            serial_number: bcs::from_bytes(script.args().get(5)?).ok()?,
        })
    } else {
        None
    }
}

type ScriptFunctionDecoderMap = std::collections::HashMap<
    String,
    Box<
        dyn Fn(&TransactionPayload) -> Option<ScriptFunctionCall>
        + std::marker::Sync
        + std::marker::Send,
    >,
>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<ScriptFunctionDecoderMap> =
    once_cell::sync::Lazy::new(|| {
        let mut map: ScriptFunctionDecoderMap = std::collections::HashMap::new();
        map.insert(
            "tokencreate_collection_script".to_string(),
            Box::new(decode_token_create_collection_script),
        );
        map.insert(
            "tokencreate_token_script".to_string(),
            Box::new(decode_token_create_token_script),
        );
        map.insert(
            "tokendirect_transfer_script".to_string(),
            Box::new(decode_token_direct_transfer_script),
        );
        map.insert(
            "tokeninitialize_token_script".to_string(),
            Box::new(decode_token_initialize_token_script),
        );
        map.insert("tokenmint".to_string(), Box::new(decode_token_mint));
        map.insert(
            "token_transferscancel_offer_script".to_string(),
            Box::new(decode_token_transfers_cancel_offer_script),
        );
        map.insert(
            "token_transfersclaim_script".to_string(),
            Box::new(decode_token_transfers_claim_script),
        );
        map.insert(
            "token_transfersoffer_script".to_string(),
            Box::new(decode_token_transfers_offer_script),
        );
        map
    });
