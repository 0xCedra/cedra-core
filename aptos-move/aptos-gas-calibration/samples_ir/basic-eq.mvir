module 0xcafe.BasicEq {
    /////////////////////////////////////////////////
    // INSTRUCTIONS:
    // * `EQ_BASE`
    // * `EQ_PER_ABS_VAL_UNIT`   
    // * `IMM_BORROW_LOC`
    // * `PACK_BASE`
    // * `PACK_PER_FIELD`

    struct Foo has drop { x: u64, y: u64 }
    struct Bar has drop { x: u64, y: u64, z: u64 }
    
    public entry calibrate_eq_with_u16() {
        let i: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        // Random small number unchanged.
        _ = to_u16(21u8) == 21u16;
        _ = to_u16(21u64) == 21u16;
        _ = to_u16(21u128) == 21u16;
        _ = to_u16(21u16) == 21u16;
        _ = to_u16(21u32) == 21u16;
        _ = to_u16(21u256) == 21u16;

        // Max representable values remain unchanged.
        _ = to_u16(255u8) == 255u16;
        _ = to_u16(65535u64) == 65535u16;
        _ = to_u16(65535u128) == 65535u16;
        _ = to_u16(65535u16) == 65535u16;
        _ = to_u16(65535u32) == 65535u16;
        _ = to_u16(65535u256) == 65535u16;                

        jump loop_start;
    label loop_end:
        return;
    }

    public entry calibrate_eq_with_u32() {
        let i: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        // Random small number unchanged.
        _ = to_u32(21u8) == 21u32;
        _ = to_u32(21u64) == 21u32;
        _ = to_u32(21u128) == 21u32;
        _ = to_u32(21u16) == 21u32;
        _ = to_u32(21u32) == 21u32;
        _ = to_u32(21u256) == 21u32;

        // Max representable values remain unchanged.
        _ = to_u32(255u8) == 255u32;
        _ = to_u32(4294967295u64) == 4294967295u32;
        _ = to_u32(4294967295u128) == 4294967295u32;
        _ = to_u32(65535u16) == 65535u32;
        _ = to_u32(4294967295u32) == 4294967295u32;
        _ = to_u32(4294967295u256) == 4294967295u32;              

        jump loop_start;
    label loop_end:
        return;
    }

    public entry calibrate_eq_with_vec() {
        let i: u64;
        let a: vector<u8>;
        let b: vector<u8>;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        a = h"000102030405060712346536356345012392385678567856785678567856785678123412341234123412341234";           
        b = h"000102030405060712346536356345012392385678567856785678567856785678123412341234123412341234";           
        _ = copy(a) == copy(b);

        jump loop_start;
    label loop_end:
        return;
    } 

    public entry calibrate_eq_with_vec_mix() {
        let a: vector<u8>;
        let b: vector<u8>;
        let c: vector<u8>;
        let d: vector<u8>;
        let e: vector<u8>;
        let f: vector<u8>;                        
        let g: vector<u8>;
        let h: vector<u8>;        
        let i: vector<u8>;
        let k: u64;
    label entry:
        k = 0;
    label loop_start:
        jump_if_false (copy(k) < 1000) loop_end;
        k = move(k) + 1;

        a = h"000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678";
        b = h"";
        c = h"000102030405060712346536356345012392385678567856785678567856785678";
        d = h"000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678";
        e = h"1234";
        f = h"000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678";
        g = h"";
        h = h"000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678";
        i = h"000102030405060712346536356345012392385678567856785678567856785678";
        _ = copy(a) == copy(b);
        _ = copy(c) == copy(d);
        _ = copy(e) == copy(f);
        _ = copy(g) == copy(h);
        _ = copy(h) == copy(i);

        a = h"000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678";
        b = h"";
        c = h"000102030405060712346536356345012392385678567856785678567856785678";
        d = h"000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678";
        e = h"1234";
        f = h"000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678";
        g = h"";
        h = h"000102030405060712346536356345012392385678567856785678567856785678000102030405060712346536356345012392385678567856785678567856785678";
        i = h"000102030405060712346536356345012392385678567856785678567856785678";
        _ = copy(a) == copy(b);
        _ = copy(c) == copy(d);
        _ = copy(e) == copy(f);
        _ = copy(g) == copy(h);
        _ = copy(h) == copy(i);

        jump loop_start;
    label loop_end:
        return;         
    }  

    public entry calibrate_eq_with_struct() {
        let i: u64;
        let a: Self.Foo;
        let b: Self.Foo;

    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;

        a = Foo { x: 0, y: 0 };
        b = Foo { x: 0, y: 0 };
        _ = &a == &b;

        i = move(i) + 1;
        jump loop_start;
    label loop_end:
        return;
    } 

    public entry calibrate_eq_with_struct_many() {
        let i: u64;
        let a: Self.Foo;
        let b: Self.Foo;
        let c: Self.Foo;

    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;

        a = Foo { x: 0, y: 0 };
        b = Foo { x: 0, y: 0 };
        c = Foo { x: 0, y: 0 };
        _ = &a == &b;
        _ = &c == &b;
        a = Foo { x: 0, y: 0 };
        b = Foo { x: 0, y: 0 };
        c = Foo { x: 0, y: 0 };
        _ = &a == &b;
        _ = &c == &b;
        a = Foo { x: 0, y: 0 };
        b = Foo { x: 0, y: 0 };
        c = Foo { x: 0, y: 0 };
        _ = &a == &b;
        _ = &c == &b;                       

        i = move(i) + 1;
        jump loop_start;
    label loop_end:
        return;
    } 

    public entry calibrate_eq_with_struct_many_different() {
        let i: u64;
        let a: Self.Foo;
        let b: Self.Foo;
        let c: Self.Bar;
        let d: Self.Bar;

    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;

        a = Foo { x: 0, y: 0 };
        b = Foo { x: 0, y: 0 };
        c = Bar { x: 0, y: 0, z: 0 };
        d = Bar { x: 0, y: 0, z: 0 };
        _ = &a == &b;
        _ = &c == &d;
        a = Foo { x: 0, y: 0 };
        b = Foo { x: 0, y: 0 };
        c = Bar { x: 0, y: 0, z: 0 };
        _ = &a == &b;
        _ = &c == &d;
        a = Foo { x: 0, y: 0 };
        b = Foo { x: 0, y: 0 };
        c = Bar { x: 0, y: 0, z: 0 };
        _ = &a == &b;
        _ = &c == &d;                      

        i = move(i) + 1;
        jump loop_start;
    label loop_end:
        return;
    }                 
}