module 0xcafe.BasicRef {
    /////////////////////////////////////////////////
    // INSTRUCTIONS:
    // * `MUT_BORROW_LOC`
    // * `IMM_BORROW_FIELD`
    // * `MUT_BORROW_FIELD`

    struct X has drop { y: Self.Y }
    struct Y has drop { u: u64 }
    struct R has key { f: bool }

    public entry calibrate_mut_borrow_loc() {
        let i: u64;
        let a: u64;
        let r: &mut u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        a = 5;
        r = &mut a;                   

        jump loop_start;
    label loop_end:
        return;  
    }

    f1() {
        let s: Self.Y;
        let y: &Self.Y;
        let u: &u64;
    label b0:
        s = Y { u: 0 };
        y = &s;
        u = &copy(y).Y::u;
        return;
    }
    public entry calibrate_imm_borrow_field() {
        let i: u64;
        let a: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        Self.f1();                  

        jump loop_start;
    label loop_end:
        return;
    }

    f2() {
        let s: Self.X;
        let x: &Self.X;
        let y: &Self.Y;
        let u: &u64;
    label b0:
        s = X { y: Y { u: 0 } };
        x = &s;
        y = &copy(x).X::y;
        u = &copy(y).Y::u;              
        return; 
    }
    public entry calibrate_imm_borrow_field_deep() {
         let i: u64;
        let a: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        Self.f2();                  

        jump loop_start;
    label loop_end:
        return;
    }

    f3() {
        let s: Self.Y;
        let y: &mut Self.Y;
        let u: &mut u64;
    label b0:
        s = Y { u: 0 };
        y = &mut s;
        u = &mut copy(y).Y::u;
        return;        
    }
    public entry calibrate_mut_borrow_field() {
        let i: u64;
        let a: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        Self.f3();                  

        jump loop_start;
    label loop_end:
        return;
    }

    f4() {
        let s: Self.X;
        let x: &mut Self.X;
        let y: &mut Self.Y;
        let u: &mut u64;
    label b0:
        s = X { y: Y { u: 0 } };
        x = &mut s;
        y = &mut copy(x).X::y;
        u = &mut copy(y).Y::u;              
        return; 
    }
    public entry calibrate_mut_borrow_field_deep() {
        let i: u64;
        let a: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        Self.f4();                  

        jump loop_start;
    label loop_end:
        return;
    }  
}