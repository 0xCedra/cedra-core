module 0xcafe.BasicRef {
    /////////////////////////////////////////////////
    // INSTRUCTIONS:
    // * `FREEZE_REF`
    // * `READ_REF`
    // * `WRITE_REF`

    struct Foo has copy, drop { x: u64, y: u64 }
    struct G has drop { v1: u64, v2: u64 }
    struct S has drop { g1: Self.G, g2: Self.G }    

    public entry calibrate_freeze_eq() {
        let i: u64;
        let x: u64;
        let r: &mut u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        x = 0;
        r = &mut x;
        _ = freeze(copy(r)) == freeze(copy(r));                  

        jump loop_start;
    label loop_end:
        return;         
    }

    public entry calibrate_freeze_eq2() {
        let i: u64;
        let x: u64;
        let r: &mut u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        x = 0;
        r = &mut x;
        _ = freeze(copy(r)) == freeze(move(r));                

        jump loop_start;
    label loop_end:
        return;         
    }    

    public entry calibrate_freeze_neq() {
        let i: u64;
        let x: u64;
        let r: &mut u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        x = 0;
        r = &mut x;
        _ = freeze(copy(r)) != freeze(copy(r));                

        jump loop_start;
    label loop_end:
        return;         
    }

    public entry calibrate_freeze_neq2() {
        let i: u64;
        let x: u64;
        let r: &mut u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        x = 0;
        r = &mut x;
        _ = freeze(copy(r)) != freeze(move(r));               

        jump loop_start;
    label loop_end:
        return;         
    }

    public entry calibrate_read_ref() {
        let i: u64;
        let v: u64;
        let read_ref: &mut u64;        
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        v = 5;
        read_ref = &mut v;              
        _ = *move(read_ref);

        jump loop_start;
    label loop_end:
        return;           
    }

    public entry calibrate_read_ref_struct() {
        let i: u64;
        let v: Self.Foo;
        let read_ref: &mut Self.Foo;        
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        v = Foo { x: 0, y: 0 };
        read_ref = &mut v;              
        _ = *move(read_ref);

        jump loop_start;
    label loop_end:
        return;           
    }

    f1() {
        let r: Self.S;
        let rmut: &mut Self.S;
        let v1_mut: &mut u64;
        let v2_mut: &mut u64;
        let g2_mut: &mut Self.G; 
    label b0:
        r = S { g1: G { v1: 0, v2: 0 }, g2: G { v1: 0, v2: 0 } };
        rmut = &mut r;

        v1_mut = &mut (&mut copy(rmut).S::g1).G::v1;
        v2_mut = &mut (&mut copy(rmut).S::g1).G::v2;

        g2_mut = &mut copy(rmut).S::g2;

        *copy(g2_mut) = G { v1: 0, v2: 0 };
        *copy(v2_mut) = 0;
        *copy(v1_mut) = 1;
        return;
    }
    public entry calibrate_write_ref_struct() {
        let i: u64;      
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        Self.f1();

        jump loop_start;
    label loop_end:
        return;
    }

    f2() {
        let a: u64;
        let b: &mut u64;
    label b0:
        a = 5;
        b = &mut a;
        *copy(b) = 0;
        return;
    }
    public entry calibrate_write_ref() {
        let i: u64;      
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        Self.f2();

        jump loop_start;
    label loop_end:
        return;
    }    
}