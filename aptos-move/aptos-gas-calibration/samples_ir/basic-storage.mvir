module 0xcafe.BasicStorage {
    /////////////////////////////////////////////////
    // INSTRUCTIONS:
    // * `EXISTS_BASE`
    // * `MOVE_FROM_BASE`
    // * `IMM_BORROW_GLOBAL_BASE`
    // * `MUT_BORROW_GLOBAL_BASE`

    struct Foo has key, store, drop { x: u64 }
    struct Bar has key, store, drop { x: u64, y: Self.Foo }

    public entry calibrate_exists() {
        let i: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        _ = exists<Foo>(0x1);
        _ = exists<Foo>(0x1);                
        _ = exists<Foo>(0x1);
        _ = exists<Foo>(0x1);
        _ = exists<Foo>(0x1);
        _ = exists<Foo>(0x1);

        jump loop_start;
    label loop_end:
        return;        
    }    


    public entry calibrate_exists_nested() {
        let i: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        _ = exists<Bar>(0x1);
        _ = exists<Bar>(0x1);                
        _ = exists<Bar>(0x1);
        _ = exists<Foo>(0x1);
        _ = exists<Foo>(0x1);
        _ = exists<Foo>(0x1);

        jump loop_start;
    label loop_end:
        return;        
    }


    f1() acquires Foo {
    label b0:
        _ = move_from<Foo>(0x1);
        return;
    }
    public entry calibrate_move_from() acquires Foo {
        let i: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        Self.f1();
        Self.f1();

        jump loop_start;
    label loop_end:
        return;         
    }

    f2() acquires Bar {
    label b0:
        _ = move_from<Bar>(0x1);
        return;
    }
    public entry calibrate_move_from_nested() acquires Bar {
        let i: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        Self.f2();
        Self.f2();

        jump loop_start;
    label loop_end:
        return;         
    } 

    public entry calibrate_imm_borrow_global() acquires Foo {
        let i: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        _ = borrow_global<Foo>(0x1);
        _ = borrow_global<Foo>(0x1);
        _ = borrow_global<Foo>(0x1);
        _ = borrow_global<Foo>(0x1);

        jump loop_start;
    label loop_end:
        return;        
    }

    public entry calibrate_imm_borrow_global_nested() acquires Bar {
        let i: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        _ = borrow_global<Bar>(0x1);
        _ = borrow_global<Bar>(0x1);
        _ = borrow_global<Bar>(0x1);
        _ = borrow_global<Bar>(0x1);

        jump loop_start;
    label loop_end:
        return;        
    } 

    public entry calibrate_mut_borrow_global() acquires Foo {
        let i: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        _ = borrow_global_mut<Foo>(0x1);
        _ = borrow_global_mut<Foo>(0x1);
        _ = borrow_global_mut<Foo>(0x1);
        _ = borrow_global_mut<Foo>(0x1);

        jump loop_start;
    label loop_end:
        return;        
    }

    public entry calibrate_mut_borrow_global_nested() acquires Bar {
        let i: u64;
    label entry:
        i = 0;
    label loop_start:
        jump_if_false (copy(i) < 1000) loop_end;
        i = move(i) + 1;

        _ = borrow_global_mut<Bar>(0x1);
        _ = borrow_global_mut<Bar>(0x1);
        _ = borrow_global_mut<Bar>(0x1);
        _ = borrow_global_mut<Bar>(0x1);

        jump loop_start;
    label loop_end:
        return;        
    }        
}