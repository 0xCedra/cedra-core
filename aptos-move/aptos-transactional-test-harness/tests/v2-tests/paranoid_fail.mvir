//# init --addresses Alice=0xf75daa73fc071f93593335eb9033da804777eb94491650dd3f095ce6f778acb6
//#      --private-keys Alice=56a26140eb233750cd14fb168c3eb4bd0782b099cde626ec8aff7f3cceb6364f

//# publish --private-key 56a26140eb233750cd14fb168c3eb4bd0782b099cde626ec8aff7f3cceb6364f --print-bytecode
module 0xf75daa73fc071f93593335eb9033da804777eb94491650dd3f095ce6f778acb6.M {
    public guess_flips(Arg0: vector<u8>) {
        let loc0: &vector<u8>;
        let loc1: u64;
        let tmp1: u8;
        let tmp2: &u8;
    label B0:
        loc0 = &Arg0;
        loc1 = 0u64;
    label B1:
        jump_if_false(copy(loc1) < vec_len<u8>(copy(loc0))) B6;
    label B2:
        jump B3;
    label B3:
        tmp2 = vec_imm_borrow<u8>(copy(loc0), copy(loc1));
        tmp1 = *copy(tmp2);
        jump_if_false (copy(tmp1) != 0u8) B5;
    label B4:
        _ = move(loc0);
        jump B6;
    label B5:
        loc1 = move(loc1) + 1u64;
        jump B1;
    label B6:
        _ = copy(Arg0);
        _ = move(Arg0);
        return;
    }

    public entry test_guess_with_inline_break() {
        let loc0: vector<u8>;
    label L0:
        loc0 = vec_pack_5<u8>(4u8, 0u8, 0u8, 0u8, 0u8);
        Self.guess_flips(move(loc0));
        return;
    }
}

//# run --signers Alice -- Alice::M::test_guess_with_inline_break
