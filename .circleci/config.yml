version: 2.1

orbs:
  aws-cli: circleci/aws-cli@2.1.0
  aws-ecr: circleci/aws-ecr@7.3.0
  kubernetes: circleci/kubernetes@1.3.0

executors:
  ubuntu-medium:
    machine:
      image: ubuntu-2004:current
    resource_class: medium
  ubuntu-large:
    machine:
      image: ubuntu-2004:current
    resource_class: large
  ubuntu-xl:
    machine:
      image: ubuntu-2004:current
    resource_class: xlarge
  ubuntu-2xl:
    machine:
      image: ubuntu-2004:current
    resource_class: 2xlarge
  docker-typescript-builder:
    docker:
      - image: circleci/node:16.13.1-browsers

jobs:
  build-benchmarks:
    executor: ubuntu-xl
    steps:
      - dev-setup
      - run: cargo x bench --no-run
  lint:
    executor: ubuntu-xl
    steps:
      - dev-setup
      - run: sudo apt-get install shellcheck --assume-yes --no-install-recommends
      - run: shellcheck scripts/dev_setup.sh
      - run: shellcheck scripts/dockerhub_prune.sh
      - run: shellcheck docker/build_push.sh
      - run: shellcheck docker/docker_republish.sh
      - run: shellcheck scripts/weekly-dep-report.sh
      - run: cargo x lint
      - run: cargo xclippy --workspace --all-targets
      - run: cargo fmt
      - run: cargo xfmt --check
  e2e-test:
    executor: ubuntu-2xl
    steps:
      - dev-setup
      - run: RUST_BACKTRACE=full cargo nextest --nextest-profile ci --partition hash:1/1 --test-threads 5 --package smoke-test
  unit-test:
    executor: ubuntu-2xl
    steps:
      - dev-setup
      - run: cargo xtest --doc --unit --changed-since "origin/main"
      - run: cargo nextest --nextest-profile ci --partition hash:1/1 --unit --exclude backup-cli --changed-since "origin/main"
  docker-build-push:
    executor: ubuntu-medium
    parameters:
      addl_tag:
        description: Additional image tag
        type: string
        default: latest
    steps:
      - checkout
      - aws-setup
      - run: echo "export IMAGE_TAG=dev_$(git rev-parse --short=8 HEAD)" >> $BASH_ENV
      - run:
          name: Build or skip
          shell: /bin/bash
          command: |
            MANIFEST=$(aws ecr batch-get-image --repository-name aptos/validator --image-ids imageTag=$IMAGE_TAG --query 'images[].imageManifest' --output text)
            echo $MANIFEST
            if [ -z "$MANIFEST" ]; then
              echo "Image tag $IMAGE_TAG not present. Starting build all..."
              ./docker/build-aws.sh --build-all --version $(git rev-parse --short=8 HEAD) --addl_tags "<<parameters.addl_tag>>"
            else
              echo "Image tag $IMAGE_TAG already present. Skipping build..."
              echo "Continue retagging to <<parameters.addl_tag>>"
              imgs=( validator forge init validator_tcb tools faucet )
              ret=0
              for img in "${imgs[@]}"
              do
                MANIFEST=$(aws ecr batch-get-image --repository-name aptos/${img} --image-ids imageTag=$IMAGE_TAG --query 'images[].imageManifest' --output text)
                put_img_out=$(aws ecr put-image --repository-name aptos/${img} --image-tag main --image-manifest "$MANIFEST" 2>&1)
                ret=$?
                # ok if image tag exists and cannot overwrite
                echo $put_img_out | grep 'ImageAlreadyExistsException' && ret=0
              done
              exit $ret
            fi
  ecr-dockerhub-mirror:
    executor: ubuntu-medium
    parameters:
      addl_tag:
        description: Additional image tag
        type: string
        default: main
    steps:
      - checkout
      - aws-setup
      - aws-ecr-setup
      - run: echo "export IMAGE_TAG=dev_$(git rev-parse --short=8 HEAD)" >> $BASH_ENV
      - run:
          name: Get latest built main image
          shell: /bin/bash
          command: |
            imgs=( validator forge init validator_tcb tools faucet )
            ret=0
            for img in "${imgs[@]}"
            do
              docker pull "${AWS_ECR_ACCOUNT_URL}/aptos/${img}:${IMAGE_TAG}" || ret=$?
            done
            exit $ret
      - run:
          name: Tag image
          shell: /bin/bash
          command: |
            imgs=( validator forge init validator_tcb tools faucet )
            org=aptoslab
            ret=0
            for img in "${imgs[@]}"
            do
              docker tag "${AWS_ECR_ACCOUNT_URL}/aptos/${img}:${IMAGE_TAG}" "${org}/${img}:${IMAGE_TAG}"
              docker tag "${AWS_ECR_ACCOUNT_URL}/aptos/${img}:${IMAGE_TAG}" "${org}/${img}:<<parameters.addl_tag>>" || ret=$?
            done
            exit $ret
      - dockerhub-setup
      - run:
          name: Push image to Dockerhub
          shell: /bin/bash
          command: |
            # imgs=( validator forge init validator_tcb tools faucet )
            imgs=( validator forge init validator_tcb tools faucet )
            org=aptoslab
            ret=0
            for img in "${imgs[@]}"
            do
              docker push "${org}/${img}:${IMAGE_TAG}"
              docker push "${org}/${img}:<<parameters.addl_tag>>" || ret=$?
            done
            exit $ret
  forge-k8s-test:
    executor: ubuntu-medium
    steps:
      - checkout
      - aws-setup
      - deploy-setup
      - run: echo "export IMAGE_TAG=dev_$(git rev-parse --short=8 HEAD)" >> $BASH_ENV
      # since we're running with `--build-all`, assume that if it passes, we have all images required for Forge
      - run: aws ecr describe-images --repository-name="aptos/validator" --image-ids=imageTag=$IMAGE_TAG
      # XXX: make forge non-blocking for now
      - run:
          name: Run Forge
          shell: /bin/bash
          command: |
            FGI_REPRO_CMD="./scripts/fgi/run --tag $IMAGE_TAG --suite land_blocking --report forge_report.json"
            eval $FGI_REPRO_CMD
            FGI_EXIT_CODE=$?
            echo "export FGI_REPRO_CMD=$FGI_REPRO_CMD" >> $BASH_ENV
            echo "export FGI_EXIT_CODE=$FGI_EXIT_CODE" >> $BASH_ENV
      - run:
          name: Post Forge test results
          shell: /bin/bash
          command: |
            commit_message=$(git log -1 --pretty=%B)
            PR_NUMBER=$(echo "${commit_message}" | grep 'Closes: #' | tail -1 | sed 's/Closes: #//')

            echo "Repro: $FGI_REPRO_CMD"

            cat \<<EOF > forge_comment.txt
            Forge run: ${CIRCLE_BUILD_URL}
            Forge Test Result: \`$(cat forge_report.json | jq -r .text)\`
            EOF
            # replace all newlines
            FORGE_COMMENT=$(awk '{printf "%s\\n", $0}' forge_comment.txt)

            curl -s -H "Authorization: token ${FORGE_GH_TOKEN}" \
            -X POST -d "{\"body\": \"${FORGE_COMMENT}\"}" \
            "https://api.github.com/repos/${CIRCLE_PROJECT_USERNAME}/${CIRCLE_PROJECT_REPONAME}/issues/${PR_NUMBER}/comments"
            exit 0
  docker-compose-test:
    executor: ubuntu-medium
    steps:
      - checkout
      - aws-setup
      - aws-ecr-setup
      - local-deploy-setup
      - run: echo "export IMAGE_TAG=dev_$(git rev-parse --short=8 HEAD)" >> $BASH_ENV
      # since we're running with `--build-all`, assume that if it passes, we have all images required for Forge
      - run: aws ecr describe-images --repository-name="aptos/validator" --image-ids=imageTag=$IMAGE_TAG
      - run:
          name: Start local testnet docker-compose
          shell: /bin/bash
          working_directory: docker/compose/validator-testnet
          command: |
            export VALIDATOR_IMAGE_REPO=${AWS_ECR_ACCOUNT_URL}/aptos/validator
            export FAUCET_IMAGE_REPO=${AWS_ECR_ACCOUNT_URL}/aptos/faucet
            docker-compose up -d
      - run:
          name: Verify testnet docker-compose up
          shell: /bin/bash
          command: |
            for i in $(seq 60); do
              curl -s -w "\n%{http_code}\n" localhost:8080 | tee >(tail -1 > validator_ret.txt)
              curl -s -w "\n%{http_code}\n" -X POST 'localhost:8000/mint?pub_key=459c77a38803bd53f3adee52703810e3a74fd7c46952c497e75afb0a7932586d&amount=20000000' \
                | tee >(tail -1 > faucet_ret.txt)
              if [ "$(cat validator_ret.txt)" = "200" ] && [ "$(cat faucet_ret.txt)" = "200" ]; then
                echo "Both validator and faucet healthy"
                exit 0
              fi
              sleep 1
            done
            exit 1
  helm-test:
    executor: ubuntu-large
    steps:
      - checkout
      - aws-setup
      - aws-ecr-setup
      - local-deploy-setup
      - deploy-setup
      - run: echo "export IMAGE_TAG=dev_$(git rev-parse --short=8 HEAD)" >> $BASH_ENV
      # since we're running with `--build-all`, assume that if it passes, we have all images required for Forge
      - run: aws ecr describe-images --repository-name="aptos/validator" --image-ids=imageTag=$IMAGE_TAG
      - run:
          name: Start Minikube
          # https://aptos.dev/tutorials/run-a-fullnode#hardware-requirements
          command: minikube start --driver=docker --cpus=2 --memory=4Gi
      - run:
          name: Wait for node status
          command: kubectl wait --for=condition=ready node/minikube --timeout=5m
      - run:
          name: Interact with the cluster
          command: kubectl get nodes
      - run:
          name: Get the images in minikube docker daemon
          command: |
            eval $(minikube docker-env)
            docker pull ${VALIDATOR_IMAGE_REPO}/${IMAGE_TAG}
            docker pull ${TOOLS_IMAGE_REPO}/${IMAGE_TAG}
      - run:
          name: Install fullnode helm chart
          working_directory: terraform/helm/fullnode
          command: |
            helm install fullnode --set storage.class=standard --set storage.size=10Gi \
              --set image.repo=$VALIDATOR_IMAGE_REPO --set image.tag=$IMAGE_TAG --set image.imagePullPolicy=Never \
              --set test.image.repo=$TOOLS_IMAGE_REPO --set test.image.tag=$IMAGE_TAG --set test.image.imagePullPolicy=Never \
              .
      - run:
          name: Wait and check pods
          command: |
            echo "Sleep 30s while fullnode starts"
            sleep 30
            kubectl wait -l statefulset.kubernetes.io/pod-name=fullnode-aptos-fullnode-0 --for=condition=ready pod --timeout=5m
            echo "Sleep 1m while fullnode syncs"
            sleep 60
            kubectl get pods
      - run:
          name: Run the fullnode helm chart tests
          working_directory: terraform/helm/fullnode
          command: helm test fullnode --logs
  sdk-typescript-test:
    executor: docker-typescript-builder
    steps:
      - checkout
      # install packages for examples
      - run: cd ./ecosystem/typescript/sdk/examples/typescript && yarn install
      - run: cd ./ecosystem/typescript/sdk/examples/javascript && yarn install
      # Run package build+lint + tests
      - run: cd ./ecosystem/typescript/sdk && yarn install
      - run: cd ./ecosystem/typescript/sdk && yarn lint
      - run: cd ./ecosystem/typescript/sdk && yarn fmt:check
      - run: cd ./ecosystem/typescript/sdk && yarn test
      - run: cd ./ecosystem/typescript/sdk && yarn build

workflows:
  ### on bors action ###
  # Build the PR binaries and run various tests
  # Build the Docker images and run Forge tests
  build-test-deploy:
    when:
      condition:
        or:
          - equal: [auto, << pipeline.git.branch >>]
          - equal: [canary, << pipeline.git.branch >>]
    jobs:
      #      - build-benchmarks
      - e2e-test
      - lint
      - unit-test
      - sdk-typescript-test
      - docker-build-push:
          context: aws-dev
      - docker-compose-test:
          context: aws-dev
          requires:
            - docker-build-push
      - forge-k8s-test:
          context: aws-dev
          requires:
            - docker-build-push
  ### on devnet branch update ###
  # Ensure the latest is built on the "devnet" branch, and mirror from ECR to Dockerhub
  devnet-branch-cut:
    when:
      equal: [devnet, << pipeline.git.branch >>]
    jobs:
      - docker-build-push:
          context: aws-dev
          addl_tag: devnet
      - ecr-dockerhub-mirror:
          context:
            - aws-dev
            - docker-aptoslabsbots
          addl_tag: devnet
          requires:
            - docker-build-push
  ### on continuous_push scheduled pipeline ###
  # Build the latest on "main" branch
  continuous-push:
    when:
      and:
        - equal: [scheduled_pipeline, << pipeline.trigger_source >>]
        - equal: ["continuous_push", << pipeline.schedule.name >>]
    jobs:
      - docker-build-push:
          context: aws-dev
          addl_tag: main
  ### on nightly scheduled pipeline ###
  # Ensure the latest on "main" branch is built, and mirror from ECR to Dockerhub
  nightly:
    when:
      and:
        - equal: [scheduled_pipeline, << pipeline.trigger_source >>]
        - equal: ["nightly", << pipeline.schedule.name >>]
    jobs:
      - docker-build-push:
          context: aws-dev
          addl_tag: main
      - ecr-dockerhub-mirror:
          context:
            - aws-dev
            - docker-aptoslabsbots
          addl_tag: main
          requires:
            - docker-build-push
commands:
  dev-setup:
    steps:
      - checkout
      - run: sudo apt-get update
      - run: sudo apt-get install build-essential ca-certificates clang curl git libssl-dev pkg-config --no-install-recommends --assume-yes
      - run: curl https://sh.rustup.rs -sSf | sh -s -- -y --default-toolchain stable
      - run: cat $HOME/.cargo/env >> $BASH_ENV
  deploy-setup:
    steps:
      - kubernetes/install-kubectl
      - run:
          name: Install Helm
          # https://helm.sh/docs/intro/install/#from-apt-debianubuntu
          command: |
            curl https://baltocdn.com/helm/signing.asc | sudo apt-key add -
            sudo apt-get install apt-transport-https --yes
            echo "deb https://baltocdn.com/helm/stable/debian/ all main" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list
            sudo apt-get update
            sudo apt-get install helm
  local-deploy-setup:
    steps:
      - run:
          name: Install Docker Compose
          command: |
            sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
            docker-compose --version
      - run:
          name: Install Minikube
          command: |
            curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
            sudo install minikube-linux-amd64 /usr/local/bin/minikube
  ### Sets up the permissions required for accessing AWS resources
  aws-setup:
    steps:
      - aws-cli/install
      # uses envs AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_REGION
      - aws-cli/setup
  ### Sets up the permissions for using AWS ECR from Docker
  aws-ecr-setup:
    steps:
      - run:
          name: Compose AWS Env Variables
          command: |
            echo 'export AWS_ECR_ACCOUNT_URL="${AWS_ECR_ACCOUNT_NUM}.dkr.ecr.${AWS_REGION}.amazonaws.com"' >> $BASH_ENV
            echo 'export VALIDATOR_IMAGE_REPO=${AWS_ECR_ACCOUNT_URL}/aptos/validator' >> $BASH_ENV
            echo 'export TOOLS_IMAGE_REPO=${AWS_ECR_ACCOUNT_URL}/aptos/tools' >> $BASH_ENV
      - aws-ecr/ecr-login
  ### Sets up the permissions for using Dockerhub
  dockerhub-setup:
    steps:
      - run:
          name: Docker login
          command: |
            echo $DOCKERHUB_PASSWORD | docker login -u $DOCKERHUB_USERNAME --password-stdin
